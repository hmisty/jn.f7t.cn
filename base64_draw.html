<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
    <title>ğŸ¨ åƒç´ å·¥åŠ Â· Jouleverse NFT</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #ccd9f0;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
        }

        /* æ ¸å¿ƒï¼šå“åº”å¼å®¹å™¨ â€” ç”µè„‘ç”¨rowï¼Œæ‰‹æœºç”¨column */
        .responsive-container {
            width: 100%;
            max-width: 1400px;
            background: #ffffff;
            border-radius: 40px 40px 32px 32px;
            box-shadow: 0 25px 50px rgba(0, 20, 60, 0.25);
            overflow: hidden;
            display: flex;
            flex-direction: row;
            transition: all 0.2s;
        }

        @media screen and (max-width: 700px) {
            .responsive-container {
                flex-direction: column;
                border-radius: 32px;
                max-width: 480px;
            }
        }

        .draw-panel {
            flex: 2.2;
            background: #f8faff;
            padding: 22px 20px;
            border-right: 1px solid #cfdff2;
            min-width: 0;
        }

        @media screen and (max-width: 700px) {
            .draw-panel {
                border-right: none;
                border-bottom: 1px solid #cfdff2;
                padding: 18px 16px;
            }
        }

        .base64-panel {
            flex: 1.2;
            background: #ffffff;
            padding: 22px 20px;
            display: flex;
            flex-direction: column;
        }

        .btn {
            background: #ffffff;
            border: 1px solid #bac8e5;
            border-radius: 40px;
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 500;
            color: #142c52;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.02);
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active { background: #e3ebfc; transform: scale(0.97); }
        .btn-primary {
            background: #2b5fd9;
            border-color: #1a3c9e;
            color: white;
            box-shadow: 0 6px 12px rgba(43,95,217,0.25);
        }
        .btn-primary:active { background: #1f4bb5; }
        .btn-active {
            background: #2b5fd9;
            color: white;
            border-color: #1742a3;
        }
        .btn-small { padding: 8px 14px; font-size: 13px; }

        .tool-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
        }

        .size-panel {
            background: #ecf3fe;
            border-radius: 50px;
            padding: 12px 18px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
            margin: 12px 0 14px;
        }
        .size-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .size-item label { font-weight: 600; color: #1e3c78; }
        .size-input {
            width: 70px;
            padding: 8px 10px;
            border: 1px solid #a3bef0;
            border-radius: 40px;
            text-align: center;
            background: white;
        }

        .color-area {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            margin: 8px 0 14px;
        }
        .color-swatch {
            width: 52px;
            height: 52px;
            border-radius: 30px;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #9cb9f0;
            background: #ff0000;
            cursor: pointer;
        }
        .color-rgb {
            background: #eaf2ff;
            padding: 8px 18px;
            border-radius: 40px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }

        .canvas-wrapper {
            background: #b7cef0;
            border-radius: 36px;
            padding: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            margin: 15px 0 8px;
            border: 1px solid #8bacdf;
            min-height: 250px;
        }
        #pixelCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            background: white;
            border: 2px solid white;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            touch-action: none;
        }

        .preview-box {
            background: #f2f8ff;
            border-radius: 28px;
            padding: 18px;
            text-align: center;
            margin-bottom: 20px;
        }
        #previewImage {
            max-width: 100%;
            max-height: 140px;
            border-radius: 20px;
            background: #e5efff;
            padding: 5px;
        }
        .radio-group {
            background: #f0f6ff;
            border-radius: 40px;
            padding: 10px 18px;
            display: flex;
            gap: 24px;
            margin: 10px 0 16px;
            border: 1px solid #c0d4f5;
        }
        .base64-text {
            width: 100%;
            min-height: 140px;
            padding: 16px;
            border-radius: 24px;
            border: 2px solid #c2d4f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: white;
            resize: vertical;
            margin: 12px 0;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }

        .import-area {
            background: #ecf2fd;
            border-radius: 28px;
            padding: 16px;
            margin: 12px 0 8px;
            border: 1px dashed #779ee0;
        }
        .file-label {
            background: white;
            padding: 12px 18px;
            border-radius: 40px;
            border: 1px solid #a1beee;
            display: inline-block;
            width: 100%;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
        }
        #imageFile { display: none; }

        .flex-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }

        .nft-mint-area {
            background: #eaeefc;
            border-radius: 28px;
            padding: 18px;
            margin-top: 18px;
            border: 1px solid #95b3e6;
        }
        .nft-title {
            font-weight: 700;
            margin-bottom: 14px;
            color: #0c2b5e;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .nft-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            margin: 12px 0;
        }
        .nft-input {
            flex: 1;
            padding: 12px 16px;
            border-radius: 60px;
            border: 1px solid #a1b5dd;
            background: white;
            font-size: 14px;
        }
        .network-badge {
            background: #2b3e6b;
            color: white;
            padding: 8px 20px;
            border-radius: 40px;
            font-size: 13px;
            font-weight: 600;
        }
        .wallet-info {
            background: #d7e4fd;
            border-radius: 30px;
            padding: 8px 18px;
            font-size: 13px;
            font-weight: 500;
            word-break: break-all;
        }
        .chain-hint {
            font-size: 12px;
            color: #2f54a0;
            background: #dfeaff;
            padding: 6px 15px;
            border-radius: 30px;
            margin-top: 8px;
        }
        .my-nfts-area {
            margin-top: 15px;
            background: #ffffff;
            border-radius: 24px;
            padding: 15px;
            border: 1px solid #c2d0f0;
            max-height: 250px;
            overflow-y: auto;
        }
        .nft-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 10px;
            border-bottom: 1px solid #e0e7ff;
        }
        .nft-item:last-child { border-bottom: none; }
        .nft-item img {
            width: 50px;
            height: 50px;
            border-radius: 12px;
            background: #f0f4ff;
            object-fit: cover;
        }
        .nft-item-info {
            flex: 1;
            font-size: 13px;
        }
        .nft-item-id {
            font-weight: 600;
            color: #1e3c8a;
        }
        .nft-burn-btn {
            background: #fee2e2;
            border: 1px solid #fecaca;
            color: #b91c1c;
            padding: 5px 12px;
            border-radius: 30px;
            font-size: 12px;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="responsive-container">
    <!-- å·¦ä¾§ç»˜å›¾åŒº -->
    <div class="draw-panel">
        <div class="tool-row">
            <button class="btn btn-active" id="drawBtn" data-mode="draw">ğŸ–Œï¸ ç”»ç¬”</button>
            <button class="btn" id="eraseBtn" data-mode="erase">ğŸ§½ æ©¡çš®</button>
            <button class="btn" id="fillBtn" data-mode="fill">ğŸª£ å¡«å……</button>
            <button class="btn btn-small" id="undoBtn">â†©ï¸ æ’¤é”€</button>
            <button class="btn btn-small" id="redoBtn">â†ªï¸ é‡åš</button>
        </div>

        <div class="size-panel">
            <div class="size-item"><label>è¡Œ</label><input type="number" id="rowsInput" class="size-input" min="1" max="128" value="16"></div>
            <div class="size-item"><label>åˆ—</label><input type="number" id="colsInput" class="size-input" min="1" max="128" value="16"></div>
            <button class="btn btn-primary btn-small" id="newCanvasBtn">âœ¨ æ–°å»º</button>
        </div>

        <div class="color-area">
            <div class="color-swatch" id="colorPickerBtn"></div>
            <span class="color-rgb" id="colorRgbLabel">RGB(255,0,0)</span>
            <div style="margin-left: auto; display: flex; gap:6px;">
                <button class="btn btn-small" id="savePngBtn">PNG</button>
                <button class="btn btn-small" id="saveJpgBtn">JPG</button>
                <button class="btn btn-small" id="saveBmpBtn">BMP</button>
                <button class="btn btn-small" id="saveIcoBtn">ICO</button>
            </div>
        </div>

        <div class="canvas-wrapper">
            <canvas id="pixelCanvas"></canvas>
        </div>

        <div class="import-area">
            <div style="font-weight:600; margin-bottom:12px;">ğŸ“¤ å¯¼å…¥å›¾ç‰‡è½¬åƒç´ /Base64</div>
            <label for="imageFile" class="file-label" id="fileLabel">ğŸ“ é€‰æ‹©å›¾ç‰‡ (è‡ªåŠ¨ç¼©å°è‡³ç”»å¸ƒå¤§å°)</label>
            <input type="file" id="imageFile" accept="image/*">
            <div class="flex-row" style="margin-top:12px; justify-content:space-between;">
                <button class="btn btn-small" id="importToCanvasBtn">â¬‡ï¸ å¯¼å…¥åˆ°ç”»å¸ƒ</button>
                <button class="btn btn-small" id="importToBase64Btn">ğŸ”„ ç›´æ¥è½¬Base64</button>
            </div>
            <div style="font-size:12px; color:#3c5e9c; margin-top:8px;">* å›¾ç‰‡ä¼šç¼©æ”¾åˆ°å½“å‰ç”»å¸ƒå°ºå¯¸</div>
        </div>
    </div>

    <!-- å³ä¾§Base64é¢æ¿ + NFT é“¸é€  -->
    <div class="base64-panel">
        <div class="preview-box">
            <div style="font-weight:700; margin-bottom:10px;">ğŸ“· é¢„è§ˆ</div>
            <img id="previewImage" src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%3Crect%20width%3D%22100%25%22%20fill%3D%22%23f3f9ff%22%2F%3E%3Ctext%20x%3D%2220%22%20y%3D%2255%22%20fill%3D%22%23305a8c%22%3Eé¢„è§ˆ%3C%2Ftext%3E%3C%2Fsvg%3E" alt="preview"; width=100px; style="image-rendering: pixelated;">
        </div>

        <div class="radio-group">
            <label><input type="radio" name="base64Format" value="with_prefix" checked> å¸¦å‰ç¼€</label>
            <label><input type="radio" name="base64Format" value="pure"> çº¯Base64</label>
        </div>

        <button class="btn btn-primary" id="convertBtn" style="margin-bottom:12px;">ğŸ”„ è½¬æ¢å½“å‰ç”»ä½œä¸ºBase64</button>
        <textarea id="base64Result" class="base64-text" placeholder="Base64è¾“å‡º..." readonly></textarea>

        <div class="button-group">
            <button class="btn" id="copyBtn" disabled style="flex:1;">ğŸ“‹ å¤åˆ¶</button>
            <button class="btn" id="saveTxtBtn" disabled style="flex:1;">ğŸ’¾ ä¿å­˜TXT</button>
        </div>

        <!-- NFT é“¸é€ åŒºåŸŸ (å·²é…ç½®Jouleverseåˆçº¦) -->
        <div class="nft-mint-area">
            <div class="nft-title">â›“ï¸ Jouleverse NFT Â· PixelArt</div>
            <div class="nft-row">
                <span class="network-badge">Jouleverse (3666)</span>
                <button class="btn btn-small" id="connectWalletBtn">ğŸ”Œ è¿æ¥é’±åŒ…</button>
            </div>
            <div id="walletAddressDisplay" class="wallet-info" style="margin-bottom:12px;">æœªè¿æ¥</div>
            
            <input type="text" id="nftNameInput" class="nft-input" placeholder="NFT åç§° (å¯é€‰)" value="PixelArt #">
            
            <div class="nft-row" style="margin-top:15px; justify-content: space-between;">
                <button class="btn btn-primary" id="mintNftBtn" style="flex:2;" disabled>ğŸ–¼ï¸ é“¸é€ NFT (å½“å‰ç”»ä½œ)</button>
                <button class="btn btn-small" id="refreshNftBtn" style="flex:1;">ğŸ”„ åˆ·æ–°æˆ‘çš„NFT</button>
            </div>
            
            <!-- æ˜¾ç¤ºç”¨æˆ·æ‹¥æœ‰çš„NFT -->
            <div id="myNftsContainer" class="my-nfts-area" style="display:none;">
                <div style="font-weight:600; margin-bottom:10px;">ğŸ“¦ æˆ‘çš„NFT (å¯é”€æ¯)</div>
                <div id="nftList"></div>
            </div>
            
            <div id="mintStatus" class="chain-hint">âš¡ å‡†å¤‡å°±ç»ªï¼Œåˆçº¦åœ°å€å·²é…ç½®</div>
        </div>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
<script>
    (function(){
        // --- åƒç´ ç”»é…ç½® ---
        let rows = 16, cols = 16;
        const PIXEL_SIZE = 20;
        let currentColor = { r:255, g:0, b:0 };
        let mode = 'draw';
        let drawing = false;
        let pixels = [];

        // å†å²è®°å½•
        let historyStack = [];
        let historyIndex = -1;
        const MAX_HISTORY = 40;

        function getSnapshot() {
            return pixels.map(row => row.map(c => ({r:c.r, g:c.g, b:c.b})));
        }
        function pushHistory() {
            if (historyIndex < historyStack.length-1) historyStack = historyStack.slice(0, historyIndex+1);
            historyStack.push(getSnapshot());
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            historyIndex = historyStack.length-1;
        }
        function undo() {
            if (historyIndex > 0) { historyIndex--; pixels = historyStack[historyIndex].map(r=>r.map(c=>({...c}))); refreshCanvas(); }
        }
        function redo() {
            if (historyIndex < historyStack.length-1) { historyIndex++; pixels = historyStack[historyIndex].map(r=>r.map(c=>({...c}))); refreshCanvas(); }
        }
        function resetHistory(initial) {
            historyStack = [initial.map(r=>r.map(c=>({...c})))];
            historyIndex = 0;
        }

        function whitePixels(r,c) {
            return Array(r).fill().map(()=>Array(c).fill().map(()=>({r:255,g:255,b:255})));
        }
        pixels = whitePixels(rows, cols);
        resetHistory(pixels);

        // DOM å…ƒç´ 
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const newCanvasBtn = document.getElementById('newCanvasBtn');
        const drawBtn = document.getElementById('drawBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const fillBtn = document.getElementById('fillBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const colorPickerBtn = document.getElementById('colorPickerBtn');
        const colorRgbLabel = document.getElementById('colorRgbLabel');
        const savePngBtn = document.getElementById('savePngBtn');
        const saveJpgBtn = document.getElementById('saveJpgBtn');
        const saveBmpBtn = document.getElementById('saveBmpBtn');
        const saveIcoBtn = document.getElementById('saveIcoBtn');
        const convertBtn = document.getElementById('convertBtn');
        const base64Result = document.getElementById('base64Result');
        const copyBtn = document.getElementById('copyBtn');
        const saveTxtBtn = document.getElementById('saveTxtBtn');
        const previewImage = document.getElementById('previewImage');
        const withPrefix = document.querySelector('input[value="with_prefix"]');
        const pureBase64 = document.querySelector('input[value="pure"]');
        const imageFileInput = document.getElementById('imageFile');
        const importToCanvasBtn = document.getElementById('importToCanvasBtn');
        const importToBase64Btn = document.getElementById('importToBase64Btn');
        const fileLabel = document.getElementById('fileLabel');

        // NFT ç›¸å…³
        const connectWalletBtn = document.getElementById('connectWalletBtn');
        const walletAddressDisplay = document.getElementById('walletAddressDisplay');
        const mintNftBtn = document.getElementById('mintNftBtn');
        const mintStatus = document.getElementById('mintStatus');
        const nftNameInput = document.getElementById('nftNameInput');
        const refreshNftBtn = document.getElementById('refreshNftBtn');
        const myNftsContainer = document.getElementById('myNftsContainer');
        const nftList = document.getElementById('nftList');

        // Jouleverse é…ç½®
        const JOULE_CHAIN_ID = 3666;
        const CONTRACT_ADDRESS = '0x2f74D6f474DC7C81BA863A32B1E5DfF9338ef21a';
        
        // åˆçº¦ABI (åŒ…å«mint, burn, ä»¥åŠæŸ¥è¯¢å‡½æ•°)
        const CONTRACT_ABI = [
            "function mint(address to, string memory uri) public returns (uint256)",
            "function burn(uint256 tokenId) public",
            "function balanceOf(address owner) view returns (uint256)",
            "function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)",
            "function tokenURI(uint256 tokenId) view returns (string)",
            "function ownerOf(uint256 tokenId) view returns (address)",
            "function totalSupply() view returns (uint256)",
            "event NFTMinted(address indexed to, uint256 indexed tokenId, string tokenURI)",
            "event NFTBurned(address indexed from, uint256 indexed tokenId)"
        ];

        let currentBase64 = '';
        let provider, signer, contract;
        let selectedAccount = null;

        // ç»˜åˆ¶ç½‘æ ¼
        function drawGrid() {
            canvas.width = cols * PIXEL_SIZE;
            canvas.height = rows * PIXEL_SIZE;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for(let i=0;i<rows;i++) {
                for(let j=0;j<cols;j++) {
                    let p = pixels[i][j];
                    ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                    ctx.fillRect(j*PIXEL_SIZE, i*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    ctx.strokeStyle = '#aaa';
                    ctx.strokeRect(j*PIXEL_SIZE, i*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                }
            }
        }
        function refreshCanvas() { drawGrid(); }

        function setActive(tool) {
            [drawBtn, eraseBtn, fillBtn].forEach(b=>b.classList.remove('btn-active'));
            if(tool==='draw') drawBtn.classList.add('btn-active');
            else if(tool==='erase') eraseBtn.classList.add('btn-active');
            else if(tool==='fill') fillBtn.classList.add('btn-active');
            mode = tool;
        }

        function getPixelIndex(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
                e.preventDefault();
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;
            if (canvasX<0 || canvasY<0 || canvasX>=canvas.width || canvasY>=canvas.height) return null;
            const col = Math.floor(canvasX / PIXEL_SIZE);
            const row = Math.floor(canvasY / PIXEL_SIZE);
            if (row<0 || row>=rows || col<0 || col>=cols) return null;
            return {row, col};
        }

        function floodFill(row, col, target, newC) {
            if (target.r===newC.r && target.g===newC.g && target.b===newC.b) return;
            let q = [{row,col}], visited = new Set();
            while(q.length) {
                let {row:r, col:c} = q.shift();
                let key = r+','+c;
                if (r<0||r>=rows||c<0||c>=cols||visited.has(key)) continue;
                let cur = pixels[r][c];
                if (cur.r!==target.r || cur.g!==target.g || cur.b!==target.b) continue;
                pixels[r][c] = {r:newC.r, g:newC.g, b:newC.b};
                visited.add(key);
                q.push({row:r+1,col:c},{row:r-1,col:c},{row:r,col:c+1},{row:r,col:c-1});
            }
        }

        function applyDraw(row, col) {
            if (mode==='draw') pixels[row][col] = {...currentColor};
            else if (mode==='erase') pixels[row][col] = {r:255,g:255,b:255};
            else if (mode==='fill') floodFill(row, col, pixels[row][col], currentColor);
            refreshCanvas();
        }

        let dirty = false;
        function onStart(e) {
            e.preventDefault();
            drawing = true;
            dirty = false;
            let idx = getPixelIndex(e);
            if (!idx) return;
            if (mode === 'fill') { pushHistory(); applyDraw(idx.row, idx.col); }
            else {
                let before = pixels[idx.row][idx.col];
                applyDraw(idx.row, idx.col);
                let after = pixels[idx.row][idx.col];
                if (before.r!==after.r||before.g!==after.g||before.b!==after.b) dirty = true;
            }
        }
        function onMove(e) {
            if (!drawing || mode==='fill') return;
            e.preventDefault();
            let idx = getPixelIndex(e);
            if (!idx) return;
            let before = pixels[idx.row][idx.col];
            applyDraw(idx.row, idx.col);
            let after = pixels[idx.row][idx.col];
            if (before.r!==after.r||before.g!==after.g||before.b!==after.b) dirty = true;
        }
        function onEnd(e) {
            e.preventDefault();
            if (drawing && dirty && mode!=='fill') pushHistory();
            drawing = false;
            dirty = false;
        }

        canvas.addEventListener('mousedown', onStart);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onEnd);
        canvas.addEventListener('mouseleave', onEnd);
        canvas.addEventListener('touchstart', onStart, {passive:false});
        canvas.addEventListener('touchmove', onMove, {passive:false});
        canvas.addEventListener('touchend', onEnd);
        canvas.addEventListener('touchcancel', onEnd);

        drawBtn.addEventListener('click', ()=>setActive('draw'));
        eraseBtn.addEventListener('click', ()=>setActive('erase'));
        fillBtn.addEventListener('click', ()=>setActive('fill'));

        colorPickerBtn.addEventListener('click', ()=>{
            let input = document.createElement('input');
            input.type = 'color';
            input.value = '#'+((1<<24)+(currentColor.r<<16)+(currentColor.g<<8)+currentColor.b).toString(16).slice(1);
            input.addEventListener('input', (e)=>{
                let hex = e.target.value;
                let r = parseInt(hex.slice(1,3),16);
                let g = parseInt(hex.slice(3,5),16);
                let b = parseInt(hex.slice(5,7),16);
                currentColor = {r,g,b};
                colorPickerBtn.style.backgroundColor = `rgb(${r},${g},${b})`;
                colorRgbLabel.innerText = `RGB(${r},${g},${b})`;
            });
            input.click();
        });

        newCanvasBtn.addEventListener('click', ()=>{
            let r = Math.min(128, Math.max(1, parseInt(rowsInput.value)||16));
            let c = Math.min(128, Math.max(1, parseInt(colsInput.value)||16));
            rows = r; cols = c;
            rowsInput.value = rows; colsInput.value = cols;
            pixels = whitePixels(rows, cols);
            resetHistory(pixels);
            refreshCanvas();
        });

        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        window.addEventListener('keydown', (e)=>{
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
            }
        });

        function saveAs(format) {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            for(let i=0;i<rows;i++) for(let j=0;j<cols;j++) { let p=pixels[i][j]; octx.fillStyle=`rgb(${p.r},${p.g},${p.b})`; octx.fillRect(j,i,1,1); }
            let mime = 'image/png', ext='png';
            if(format==='jpg') { mime='image/jpeg'; ext='jpg'; }
            else if(format==='bmp') { mime='image/bmp'; ext='bmp'; }
            else if(format==='ico') { mime='image/x-icon'; ext='ico'; }
            off.toBlob(blob=>{
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a');
                a.href = url; a.download = `pixel.${ext}`; a.click();
                URL.revokeObjectURL(url);
            }, mime);
        }
        savePngBtn.addEventListener('click', ()=>saveAs('png'));
        saveJpgBtn.addEventListener('click', ()=>saveAs('jpg'));
        saveBmpBtn.addEventListener('click', ()=>saveAs('bmp'));
        saveIcoBtn.addEventListener('click', ()=>saveAs('ico'));

        convertBtn.addEventListener('click', ()=>{
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            for(let i=0;i<rows;i++) for(let j=0;j<cols;j++) { let p=pixels[i][j]; octx.fillStyle=`rgb(${p.r},${p.g},${p.b})`; octx.fillRect(j,i,1,1); }
            off.toBlob(blob=>{
                let reader = new FileReader();
                reader.onloadend = ()=>{
                    let base64 = reader.result.split(',')[1];
                    let prefix = 'data:image/png;base64,';
                    currentBase64 = withPrefix.checked ? prefix+base64 : base64;
                    base64Result.value = currentBase64;
                    copyBtn.disabled = false;
                    saveTxtBtn.disabled = false;
                    previewImage.src = off.toDataURL('image/png');
                };
                reader.readAsDataURL(blob);
            }, 'image/png');
        });

        copyBtn.addEventListener('click', ()=>{
            if (currentBase64) { navigator.clipboard.writeText(currentBase64); }
        });
        saveTxtBtn.addEventListener('click', ()=>{
            if (!currentBase64) return;
            let blob = new Blob([currentBase64], {type:'text/plain'});
            let url = URL.createObjectURL(blob);
            let a = document.createElement('a');
            a.href = url; a.download = 'base64.txt'; a.click();
            URL.revokeObjectURL(url);
        });

        function loadImageFile(file, callback) {
            if (!file) return;
            let reader = new FileReader();
            reader.onload = (e) => {
                let img = new Image();
                img.onload = () => callback(img);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function importImageToCanvas(img) {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            octx.drawImage(img, 0, 0, cols, rows);
            let imageData = octx.getImageData(0, 0, cols, rows).data;
            for (let i=0; i<rows; i++) {
                for (let j=0; j<cols; j++) {
                    let idx = (i * cols + j) * 4;
                    pixels[i][j] = { r: imageData[idx], g: imageData[idx+1], b: imageData[idx+2] };
                }
            }
            pushHistory();
            refreshCanvas();
        }

        function importToBase64Only(img) {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            octx.drawImage(img, 0, 0, cols, rows);
            let base64 = off.toDataURL('image/png');
            let pure = base64.split(',')[1];
            currentBase64 = withPrefix.checked ? base64 : pure;
            base64Result.value = currentBase64;
            copyBtn.disabled = false;
            saveTxtBtn.disabled = false;
            previewImage.src = base64;
        }

        imageFileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                fileLabel.innerText = `ğŸ“ ${e.target.files[0].name}`;
            } else {
                fileLabel.innerText = 'ğŸ“ é€‰æ‹©å›¾ç‰‡ (è‡ªåŠ¨ç¼©å°è‡³ç”»å¸ƒå¤§å°)';
            }
        });

        importToCanvasBtn.addEventListener('click', () => {
            if (!imageFileInput.files.length) { alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡'); return; }
            loadImageFile(imageFileInput.files[0], (img) => {
                importImageToCanvas(img);
            });
        });

        importToBase64Btn.addEventListener('click', () => {
            if (!imageFileInput.files.length) { alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡'); return; }
            loadImageFile(imageFileInput.files[0], (img) => {
                importToBase64Only(img);
            });
        });

        rowsInput.addEventListener('change', function(){ let v=parseInt(this.value); if(v>128) this.value=128; if(v<1) this.value=1; });
        colsInput.addEventListener('change', function(){ let v=parseInt(this.value); if(v>128) this.value=128; if(v<1) this.value=1; });

        // ========== åŒºå—é“¾äº¤äº’ ==========
        async function connectWallet() {
            if (!window.ethereum) {
                alert('è¯·å®‰è£…MetaMaskæˆ–å…¼å®¹é’±åŒ…');
                return;
            }
            try {
                provider = new ethers.providers.Web3Provider(window.ethereum);
                await provider.send('eth_requestAccounts', []);
                signer = provider.getSigner();
                selectedAccount = await signer.getAddress();
                
                const network = await provider.getNetwork();
                if (network.chainId !== JOULE_CHAIN_ID) {
                    mintStatus.innerText = 'âš ï¸ è¯·åˆ‡æ¢åˆ°Jouleverseç½‘ç»œ (ChainID 3666)';
                    mintNftBtn.disabled = true;
                    walletAddressDisplay.innerText = `${selectedAccount.substring(0,10)}... (é”™è¯¯ç½‘ç»œ)`;
                    return;
                }
                
                walletAddressDisplay.innerText = `ğŸ“Œ ${selectedAccount.substring(0,10)}...${selectedAccount.substring(38)}`;
                mintNftBtn.disabled = false;
                mintStatus.innerText = 'âœ… å·²è¿æ¥åˆ°Jouleverse';
                
                // åˆå§‹åŒ–åˆçº¦
                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);
                
                // åŠ è½½ç”¨æˆ·NFT
                loadUserNFTs();
                myNftsContainer.style.display = 'block';
            } catch (err) {
                console.error(err);
                walletAddressDisplay.innerText = 'è¿æ¥å¤±è´¥';
            }
        }

        async function loadUserNFTs() {
            if (!contract || !selectedAccount) return;
            try {
                const balance = await contract.balanceOf(selectedAccount);
                if (balance == 0) {
                    nftList.innerHTML = '<div style="color:#666; text-align:center;">æš‚æ— NFTï¼Œé“¸é€ ä¸€ä¸ªå§</div>';
                    return;
                }
                
                let html = '';
                for (let i = 0; i < balance; i++) {
                    const tokenId = await contract.tokenOfOwnerByIndex(selectedAccount, i);
                    const uri = await contract.tokenURI(tokenId);
                    
                    html += `
                        <div class="nft-item">
                            <img src="${uri.startsWith('data:') ? uri : 'data:image/svg+xml,%3Csvg...'}" onerror="this.src='data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%2250%22%20height%3D%2250%22%3E%3Crect%20width%3D%2250%22%20height%3D%2250%22%20fill%3D%22%23cccccc%22%2F%3E%3C%2Fsvg%3E'">
                            <div class="nft-item-info">
                                <div class="nft-item-id">#${tokenId.toString()}</div>
                                <div style="font-size:11px; color:#666;">${uri.substring(0,30)}...</div>
                            </div>
                            <button class="nft-burn-btn" data-tokenid="${tokenId}">ğŸ”¥ é”€æ¯</button>
                        </div>
                    `;
                }
                nftList.innerHTML = html;
                
                // ç»‘å®šé”€æ¯äº‹ä»¶
                document.querySelectorAll('.nft-burn-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const tokenId = e.target.dataset.tokenid;
                        if (confirm(`ç¡®å®šè¦é”€æ¯ NFT #${tokenId} å—ï¼Ÿ`)) {
                            try {
                                const tx = await contract.burn(tokenId);
                                mintStatus.innerText = 'â³ é”€æ¯äº¤æ˜“å‘é€ä¸­...';
                                await tx.wait();
                                mintStatus.innerText = 'âœ… é”€æ¯æˆåŠŸ';
                                loadUserNFTs(); // åˆ·æ–°åˆ—è¡¨
                            } catch (err) {
                                mintStatus.innerText = `âŒ é”€æ¯å¤±è´¥: ${err.message.substring(0,50)}`;
                            }
                        }
                    });
                });
            } catch (err) {
                console.error(err);
                nftList.innerHTML = '<div style="color:#b91c1c;">åŠ è½½å¤±è´¥</div>';
            }
        }

        connectWalletBtn.addEventListener('click', connectWallet);

        refreshNftBtn.addEventListener('click', async () => {
            if (!contract || !selectedAccount) {
                mintStatus.innerText = 'è¯·å…ˆè¿æ¥é’±åŒ…';
                return;
            }
            await loadUserNFTs();
            mintStatus.innerText = 'âœ… NFTåˆ—è¡¨å·²åˆ·æ–°';
        });

        mintNftBtn.addEventListener('click', async () => {
            if (!contract || !selectedAccount) {
                mintStatus.innerText = 'è¯·å…ˆè¿æ¥é’±åŒ…';
                return;
            }
            if (!currentBase64) {
                mintStatus.innerText = 'è¯·å…ˆç”ŸæˆBase64 (è½¬æ¢å½“å‰ç”»ä½œ)';
                return;
            }
            
            // ç¡®ä¿ä½¿ç”¨å¸¦å‰ç¼€çš„æ ¼å¼
            let tokenURI = currentBase64;
            if (!tokenURI.startsWith('data:image')) {
                tokenURI = 'data:image/png;base64,' + tokenURI;
            }
            
            try {
                mintStatus.innerText = 'â³ é“¸é€ äº¤æ˜“å‘é€ä¸­...';
                const tx = await contract.mint(selectedAccount, tokenURI);
                mintStatus.innerText = `äº¤æ˜“å·²å‘é€: ${tx.hash.substring(0,10)}... ç­‰å¾…ç¡®è®¤`;
                await tx.wait();
                mintStatus.innerText = `âœ… é“¸é€ æˆåŠŸ! Token ID: ${(await contract.totalSupply()).toString()}`;
                await loadUserNFTs();
            } catch (err) {
                console.error(err);
                mintStatus.innerText = `âŒ é“¸é€ å¤±è´¥: ${err.message.substring(0,60)}`;
            }
        });

        // åˆå§‹åŒ–
        refreshCanvas();
        setActive('draw');
        
        // é¢„è®¾é»˜è®¤Base64ä¸ºç©ºç™½ç”»å¸ƒ
        (function initBase64() {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            for(let i=0;i<rows;i++) for(let j=0;j<cols;j++) octx.fillStyle='#ffffff', octx.fillRect(j,i,1,1);
            currentBase64 = off.toDataURL('image/png').split(',')[1];
            currentBase64 = withPrefix.checked ? 'data:image/png;base64,' + currentBase64 : currentBase64;
            base64Result.value = currentBase64;
            previewImage.src = off.toDataURL('image/png');
        })();
    })();
</script>
</body>
</html>
