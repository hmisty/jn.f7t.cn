<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
    <title>ğŸ¨ åƒç´ å·¥åŠ</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: #ccd9f0;
            font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
        }

        /* æ ¸å¿ƒï¼šå“åº”å¼å®¹å™¨ â€” ç”µè„‘ç”¨rowï¼Œæ‰‹æœºç”¨column */
        .responsive-container {
            width: 100%;
            max-width: 1400px;
            background: #ffffff;
            border-radius: 40px 40px 32px 32px;
            box-shadow: 0 25px 50px rgba(0, 20, 60, 0.25);
            overflow: hidden;
            display: flex;
            flex-direction: row;          /* ç”µè„‘æ¨ªæ’ */
            transition: all 0.2s;
        }

        /* æ‰‹æœºç«–æ’ (max-width: 700px) */
        @media screen and (max-width: 700px) {
            .responsive-container {
                flex-direction: column;    /* æ‰‹æœºç«–æ’ */
                border-radius: 32px;
                max-width: 480px;
            }
        }

        /* å·¦ä¾§ç»˜å›¾åŒº â€” ç”µè„‘å®½ä¸€äº›ï¼Œæ‰‹æœºè‡ªåŠ¨ */
        .draw-panel {
            flex: 2.2;
            background: #f8faff;
            padding: 22px 20px;
            border-right: 1px solid #cfdff2;
            min-width: 0;                 /* é˜²æ­¢æº¢å‡º */
        }

        @media screen and (max-width: 700px) {
            .draw-panel {
                border-right: none;
                border-bottom: 1px solid #cfdff2;
                padding: 18px 16px;
            }
        }

        /* å³ä¾§Base64é¢æ¿ */
        .base64-panel {
            flex: 1.2;
            background: #ffffff;
            padding: 22px 20px;
            display: flex;
            flex-direction: column;
        }

        /* é€šç”¨æ§ä»¶ */
        .btn {
            background: #ffffff;
            border: 1px solid #bac8e5;
            border-radius: 40px;
            padding: 10px 18px;
            font-size: 14px;
            font-weight: 500;
            color: #142c52;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            cursor: pointer;
            transition: 0.1s;
            box-shadow: 0 2px 6px rgba(0,0,0,0.02);
            -webkit-tap-highlight-color: transparent;
        }
        .btn:active { background: #e3ebfc; transform: scale(0.97); }
        .btn-primary {
            background: #2b5fd9;
            border-color: #1a3c9e;
            color: white;
            box-shadow: 0 6px 12px rgba(43,95,217,0.25);
        }
        .btn-primary:active { background: #1f4bb5; }
        .btn-active {
            background: #2b5fd9;
            color: white;
            border-color: #1742a3;
        }
        .btn-small { padding: 8px 14px; font-size: 13px; }

        .tool-row {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 8px;
            margin-bottom: 14px;
        }

        .size-panel {
            background: #ecf3fe;
            border-radius: 50px;
            padding: 12px 18px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 15px;
            margin: 12px 0 14px;
        }
        .size-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .size-item label { font-weight: 600; color: #1e3c78; }
        .size-input {
            width: 70px;
            padding: 8px 10px;
            border: 1px solid #a3bef0;
            border-radius: 40px;
            text-align: center;
            background: white;
        }

        .color-area {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            margin: 8px 0 14px;
        }
        .color-swatch {
            width: 52px;
            height: 52px;
            border-radius: 30px;
            border: 3px solid white;
            box-shadow: 0 0 0 2px #9cb9f0;
            background: #ff0000;
            cursor: pointer;
        }
        .color-rgb {
            background: #eaf2ff;
            padding: 8px 18px;
            border-radius: 40px;
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }

        /* ç”»å¸ƒå®¹å™¨ */
        .canvas-wrapper {
            background: #b7cef0;
            border-radius: 36px;
            padding: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: auto;
            margin: 15px 0 8px;
            border: 1px solid #8bacdf;
            min-height: 250px;
        }
        #pixelCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            background: white;
            border: 2px solid white;
            box-shadow: 0 10px 20px rgba(0,0,0,0.2);
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            touch-action: none;
        }

        /* å³ä¾§åŒºåŸŸ */
        .preview-box {
            background: #f2f8ff;
            border-radius: 28px;
            padding: 18px;
            text-align: center;
            margin-bottom: 20px;
        }
        #previewImage {
            max-width: 100%;
            max-height: 140px;
            border-radius: 20px;
            background: #e5efff;
            padding: 5px;
        }
        .radio-group {
            background: #f0f6ff;
            border-radius: 40px;
            padding: 10px 18px;
            display: flex;
            gap: 24px;
            margin: 10px 0 16px;
            border: 1px solid #c0d4f5;
        }
        .base64-text {
            width: 100%;
            min-height: 140px;
            padding: 16px;
            border-radius: 24px;
            border: 2px solid #c2d4f0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            background: white;
            resize: vertical;
            margin: 12px 0;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 6px;
        }

        /* å¯¼å…¥åŒº */
        .import-area {
            background: #ecf2fd;
            border-radius: 28px;
            padding: 16px;
            margin: 12px 0 8px;
            border: 1px dashed #779ee0;
        }
        .file-label {
            background: white;
            padding: 12px 18px;
            border-radius: 40px;
            border: 1px solid #a1beee;
            display: inline-block;
            width: 100%;
            text-align: center;
            font-weight: 500;
            cursor: pointer;
        }
        #imageFile { display: none; }
        }

        .flex-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    </style>
</head>
<body>
<div class="responsive-container">
    <!-- å·¦ä¾§ç»˜å›¾åŒº -->
    <div class="draw-panel">
        <div class="tool-row">
            <button class="btn btn-active" id="drawBtn" data-mode="draw">ğŸ–Œï¸ ç”»ç¬”</button>
            <button class="btn" id="eraseBtn" data-mode="erase">ğŸ§½ æ©¡çš®</button>
            <button class="btn" id="fillBtn" data-mode="fill">ğŸª£ å¡«å……</button>
            <button class="btn btn-small" id="undoBtn">â†©ï¸ æ’¤é”€</button>
            <button class="btn btn-small" id="redoBtn">â†ªï¸ é‡åš</button>
        </div>

        <div class="size-panel">
            <div class="size-item"><label>è¡Œ</label><input type="number" id="rowsInput" class="size-input" min="1" max="128" value="16"></div>
            <div class="size-item"><label>åˆ—</label><input type="number" id="colsInput" class="size-input" min="1" max="128" value="16"></div>
            <button class="btn btn-primary btn-small" id="newCanvasBtn">âœ¨ æ–°å»º</button>
        </div>

        <div class="color-area">
            <div class="color-swatch" id="colorPickerBtn"></div>
            <span class="color-rgb" id="colorRgbLabel">RGB(255,0,0)</span>
            <div style="margin-left: auto; display: flex; gap:6px;">
                <button class="btn btn-small" id="savePngBtn">PNG</button>
                <button class="btn btn-small" id="saveJpgBtn">JPG</button>
                <button class="btn btn-small" id="saveBmpBtn">BMP</button>
                <button class="btn btn-small" id="saveIcoBtn">ICO</button>
            </div>
        </div>

        <!-- ç”»å¸ƒ -->
        <div class="canvas-wrapper">
            <canvas id="pixelCanvas"></canvas>
        </div>

        <!-- æ–°å¢ï¼šå¯¼å…¥å›¾ç‰‡è½¬åƒç´  -->
        <div class="import-area">
            <div style="font-weight:600; margin-bottom:12px;">ğŸ“¤ å¯¼å…¥å›¾ç‰‡è½¬åƒç´ /Base64</div>
            <label for="imageFile" class="file-label" id="fileLabel">ğŸ“ é€‰æ‹©å›¾ç‰‡ (è‡ªåŠ¨ç¼©å°è‡³ç”»å¸ƒå¤§å°)</label>
            <input type="file" id="imageFile" accept="image/*">
            <div class="flex-row" style="margin-top:12px; justify-content:space-between;">
                <button class="btn btn-small" id="importToCanvasBtn">â¬‡ï¸ å¯¼å…¥åˆ°ç”»å¸ƒ</button>
                <button class="btn btn-small" id="importToBase64Btn">ğŸ”„ ç›´æ¥è½¬Base64</button>
            </div>
            <div style="font-size:12px; color:#3c5e9c; margin-top:8px;">* å›¾ç‰‡ä¼šç¼©æ”¾åˆ°å½“å‰ç”»å¸ƒå°ºå¯¸ (è¡Œåˆ—æ•°)</div>
        </div>
    </div>

    <!-- å³ä¾§Base64é¢æ¿ -->
    <div class="base64-panel">
        <div class="preview-box">
            <div style="font-weight:700; margin-bottom:10px;">ğŸ“· é¢„è§ˆ</div>
            <img id="previewImage" src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%22%20height%3D%22100%22%20viewBox%3D%220%200%20100%20100%22%3E%3Crect%20width%3D%22100%25%22%20fill%3D%22%23f3f9ff%22%2F%3E%3Ctext%20x%3D%2220%22%20y%3D%2255%22%20fill%3D%22%23305a8c%22%3Eé¢„è§ˆ%3C%2Ftext%3E%3C%2Fsvg%3E" alt="preview"; width=100px; style="image-rendering: pixelated;">
        </div>

        <div class="radio-group">
            <label><input type="radio" name="base64Format" value="with_prefix" checked> å¸¦å‰ç¼€</label>
            <label><input type="radio" name="base64Format" value="pure"> çº¯Base64</label>
        </div>

        <button class="btn btn-primary" id="convertBtn" style="margin-bottom:12px;">ğŸ”„ è½¬æ¢å½“å‰ç”»ä½œä¸ºBase64</button>
        <textarea id="base64Result" class="base64-text" placeholder="Base64è¾“å‡º..." readonly></textarea>

        <div class="button-group">
            <button class="btn" id="copyBtn" disabled style="flex:1;">ğŸ“‹ å¤åˆ¶</button>
            <button class="btn" id="saveTxtBtn" disabled style="flex:1;">ğŸ’¾ ä¿å­˜TXT</button>
        </div>
    </div>
</div>

<script>
    (function(){
        // --- é…ç½® ---
        let rows = 16, cols = 16;
        const PIXEL_SIZE = 20;    // é€»è¾‘åƒç´ 
        let currentColor = { r:255, g:0, b:0 };
        let mode = 'draw';
        let drawing = false;

        let pixels = [];

        // å†å²
        let historyStack = [];
        let historyIndex = -1;
        const MAX_HISTORY = 40;

        function getSnapshot() {
            return pixels.map(row => row.map(c => ({r:c.r, g:c.g, b:c.b})));
        }
        function pushHistory() {
            if (historyIndex < historyStack.length-1) historyStack = historyStack.slice(0, historyIndex+1);
            historyStack.push(getSnapshot());
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
            historyIndex = historyStack.length-1;
        }
        function undo() {
            if (historyIndex > 0) { historyIndex--; pixels = historyStack[historyIndex].map(r=>r.map(c=>({...c}))); refreshCanvas(); }
        }
        function redo() {
            if (historyIndex < historyStack.length-1) { historyIndex++; pixels = historyStack[historyIndex].map(r=>r.map(c=>({...c}))); refreshCanvas(); }
        }
        function resetHistory(initial) {
            historyStack = [initial.map(r=>r.map(c=>({...c})))];
            historyIndex = 0;
        }

        // ç™½è‰²èƒŒæ™¯
        function whitePixels(r,c) {
            return Array(r).fill().map(()=>Array(c).fill().map(()=>({r:255,g:255,b:255})));
        }
        pixels = whitePixels(rows, cols);
        resetHistory(pixels);

        // DOM
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const newCanvasBtn = document.getElementById('newCanvasBtn');
        const drawBtn = document.getElementById('drawBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const fillBtn = document.getElementById('fillBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const colorPickerBtn = document.getElementById('colorPickerBtn');
        const colorRgbLabel = document.getElementById('colorRgbLabel');
        const savePngBtn = document.getElementById('savePngBtn');
        const saveJpgBtn = document.getElementById('saveJpgBtn');
        const saveBmpBtn = document.getElementById('saveBmpBtn');
        const saveIcoBtn = document.getElementById('saveIcoBtn');
        const convertBtn = document.getElementById('convertBtn');
        const base64Result = document.getElementById('base64Result');
        const copyBtn = document.getElementById('copyBtn');
        const saveTxtBtn = document.getElementById('saveTxtBtn');
        const previewImage = document.getElementById('previewImage');
        const withPrefix = document.querySelector('input[value="with_prefix"]');
        const pureBase64 = document.querySelector('input[value="pure"]');

        // å¯¼å…¥ç›¸å…³
        const imageFileInput = document.getElementById('imageFile');
        const importToCanvasBtn = document.getElementById('importToCanvasBtn');
        const importToBase64Btn = document.getElementById('importToBase64Btn');
        const fileLabel = document.getElementById('fileLabel');

        let currentBase64 = '';

        // ç»˜åˆ¶ç½‘æ ¼
        function drawGrid() {
            canvas.width = cols * PIXEL_SIZE;
            canvas.height = rows * PIXEL_SIZE;
            ctx.clearRect(0,0,canvas.width,canvas.height);
            for(let i=0;i<rows;i++) {
                for(let j=0;j<cols;j++) {
                    let p = pixels[i][j];
                    ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                    ctx.fillRect(j*PIXEL_SIZE, i*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    ctx.strokeStyle = '#aaa';
                    ctx.strokeRect(j*PIXEL_SIZE, i*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                }
            }
        }
        function refreshCanvas() { drawGrid(); }

        // æ¿€æ´»å·¥å…·æ ·å¼
        function setActive(tool) {
            [drawBtn, eraseBtn, fillBtn].forEach(b=>b.classList.remove('btn-active'));
            if(tool==='draw') drawBtn.classList.add('btn-active');
            else if(tool==='erase') eraseBtn.classList.add('btn-active');
            else if(tool==='fill') fillBtn.classList.add('btn-active');
            mode = tool;
        }

        // åæ ‡è½¬æ¢ (æ”¯æŒè§¦æ‘¸)
        function getPixelIndex(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
                e.preventDefault();
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            const canvasX = (clientX - rect.left) * scaleX;
            const canvasY = (clientY - rect.top) * scaleY;
            if (canvasX<0 || canvasY<0 || canvasX>=canvas.width || canvasY>=canvas.height) return null;
            const col = Math.floor(canvasX / PIXEL_SIZE);
            const row = Math.floor(canvasY / PIXEL_SIZE);
            if (row<0 || row>=rows || col<0 || col>=cols) return null;
            return {row, col};
        }

        // å¡«å……
        function floodFill(row, col, target, newC) {
            if (target.r===newC.r && target.g===newC.g && target.b===newC.b) return;
            let q = [{row,col}], visited = new Set();
            while(q.length) {
                let {row:r, col:c} = q.shift();
                let key = r+','+c;
                if (r<0||r>=rows||c<0||c>=cols||visited.has(key)) continue;
                let cur = pixels[r][c];
                if (cur.r!==target.r || cur.g!==target.g || cur.b!==target.b) continue;
                pixels[r][c] = {r:newC.r, g:newC.g, b:newC.b};
                visited.add(key);
                q.push({row:r+1,col:c},{row:r-1,col:c},{row:r,col:c+1},{row:r,col:c-1});
            }
        }

        function applyDraw(row, col) {
            if (mode==='draw') pixels[row][col] = {...currentColor};
            else if (mode==='erase') pixels[row][col] = {r:255,g:255,b:255};
            else if (mode==='fill') floodFill(row, col, pixels[row][col], currentColor);
            refreshCanvas();
        }

        // æ‹–æ‹½ç»˜åˆ¶
        let dirty = false;
        function onStart(e) {
            e.preventDefault();
            drawing = true;
            dirty = false;
            let idx = getPixelIndex(e);
            if (!idx) return;
            if (mode === 'fill') { pushHistory(); applyDraw(idx.row, idx.col); }
            else {
                let before = pixels[idx.row][idx.col];
                applyDraw(idx.row, idx.col);
                let after = pixels[idx.row][idx.col];
                if (before.r!==after.r||before.g!==after.g||before.b!==after.b) dirty = true;
            }
        }
        function onMove(e) {
            if (!drawing || mode==='fill') return;
            e.preventDefault();
            let idx = getPixelIndex(e);
            if (!idx) return;
            let before = pixels[idx.row][idx.col];
            applyDraw(idx.row, idx.col);
            let after = pixels[idx.row][idx.col];
            if (before.r!==after.r||before.g!==after.g||before.b!==after.b) dirty = true;
        }
        function onEnd(e) {
            e.preventDefault();
            if (drawing && dirty && mode!=='fill') pushHistory();
            drawing = false;
            dirty = false;
        }

        canvas.addEventListener('mousedown', onStart);
        canvas.addEventListener('mousemove', onMove);
        canvas.addEventListener('mouseup', onEnd);
        canvas.addEventListener('mouseleave', onEnd);
        canvas.addEventListener('touchstart', onStart, {passive:false});
        canvas.addEventListener('touchmove', onMove, {passive:false});
        canvas.addEventListener('touchend', onEnd);
        canvas.addEventListener('touchcancel', onEnd);

        drawBtn.addEventListener('click', ()=>setActive('draw'));
        eraseBtn.addEventListener('click', ()=>setActive('erase'));
        fillBtn.addEventListener('click', ()=>setActive('fill'));

        // é¢œè‰²é€‰æ‹©
        colorPickerBtn.addEventListener('click', ()=>{
            let input = document.createElement('input');
            input.type = 'color';
            input.value = '#'+((1<<24)+(currentColor.r<<16)+(currentColor.g<<8)+currentColor.b).toString(16).slice(1);
            input.addEventListener('input', (e)=>{
                let hex = e.target.value;
                let r = parseInt(hex.slice(1,3),16);
                let g = parseInt(hex.slice(3,5),16);
                let b = parseInt(hex.slice(5,7),16);
                currentColor = {r,g,b};
                colorPickerBtn.style.backgroundColor = `rgb(${r},${g},${b})`;
                colorRgbLabel.innerText = `RGB(${r},${g},${b})`;
            });
            input.click();
        });

        // æ–°å»º
        newCanvasBtn.addEventListener('click', ()=>{
            let r = Math.min(128, Math.max(1, parseInt(rowsInput.value)||16));
            let c = Math.min(128, Math.max(1, parseInt(colsInput.value)||16));
            rows = r; cols = c;
            rowsInput.value = rows; colsInput.value = cols;
            pixels = whitePixels(rows, cols);
            resetHistory(pixels);
            refreshCanvas();
        });

        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        window.addEventListener('keydown', (e)=>{
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
            }
        });

        // ä¿å­˜å›¾ç‰‡
        function saveAs(format) {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            for(let i=0;i<rows;i++) for(let j=0;j<cols;j++) { let p=pixels[i][j]; octx.fillStyle=`rgb(${p.r},${p.g},${p.b})`; octx.fillRect(j,i,1,1); }
            let mime = 'image/png', ext='png';
            if(format==='jpg') { mime='image/jpeg'; ext='jpg'; }
            else if(format==='bmp') { mime='image/bmp'; ext='bmp'; }
            else if(format==='ico') { mime='image/x-icon'; ext='ico'; }
            off.toBlob(blob=>{
                let url = URL.createObjectURL(blob);
                let a = document.createElement('a');
                a.href = url; a.download = `pixel.${ext}`; a.click();
                URL.revokeObjectURL(url);
            }, mime);
        }
        savePngBtn.addEventListener('click', ()=>saveAs('png'));
        saveJpgBtn.addEventListener('click', ()=>saveAs('jpg'));
        saveBmpBtn.addEventListener('click', ()=>saveAs('bmp'));
        saveIcoBtn.addEventListener('click', ()=>saveAs('ico'));

        // Base64 è½¬æ¢ (å½“å‰ç”»å¸ƒ)
        convertBtn.addEventListener('click', ()=>{
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            for(let i=0;i<rows;i++) for(let j=0;j<cols;j++) { let p=pixels[i][j]; octx.fillStyle=`rgb(${p.r},${p.g},${p.b})`; octx.fillRect(j,i,1,1); }
            off.toBlob(blob=>{
                let reader = new FileReader();
                reader.onloadend = ()=>{
                    let base64 = reader.result.split(',')[1];
                    let prefix = 'data:image/png;base64,';
                    currentBase64 = withPrefix.checked ? prefix+base64 : base64;
                    base64Result.value = currentBase64;
                    copyBtn.disabled = false;
                    saveTxtBtn.disabled = false;
                    previewImage.src = off.toDataURL('image/png');
                };
                reader.readAsDataURL(blob);
            }, 'image/png');
        });

        copyBtn.addEventListener('click', ()=>{
            if (currentBase64) { navigator.clipboard.writeText(currentBase64); }
        });
        saveTxtBtn.addEventListener('click', ()=>{
            if (!currentBase64) return;
            let blob = new Blob([currentBase64], {type:'text/plain'});
            let url = URL.createObjectURL(blob);
            let a = document.createElement('a');
            a.href = url; a.download = 'base64.txt'; a.click();
            URL.revokeObjectURL(url);
        });

        // ---------- å¯¼å…¥å›¾ç‰‡åŠŸèƒ½ ----------
        function loadImageFile(file, callback) {
            if (!file) return;
            let reader = new FileReader();
            reader.onload = (e) => {
                let img = new Image();
                img.onload = () => callback(img);
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // å°†å›¾ç‰‡ç¼©æ”¾åˆ°å½“å‰ç”»å¸ƒå°ºå¯¸ï¼Œå¹¶è®¾ç½®åƒç´ çŸ©é˜µ (è¿‘ä¼¼)
        function importImageToCanvas(img) {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            octx.drawImage(img, 0, 0, cols, rows);  // ç¼©æ”¾åˆ°ç”»å¸ƒå¤§å°
            let imageData = octx.getImageData(0, 0, cols, rows).data;
            // æ›´æ–°pixels
            for (let i=0; i<rows; i++) {
                for (let j=0; j<cols; j++) {
                    let idx = (i * cols + j) * 4;
                    pixels[i][j] = { r: imageData[idx], g: imageData[idx+1], b: imageData[idx+2] };
                }
            }
            pushHistory();
            refreshCanvas();
        }

        // ç›´æ¥è½¬Base64 (ä½¿ç”¨å›¾ç‰‡æœ¬èº«ä¸æ”¹å˜ç”»å¸ƒ)
        function importToBase64Only(img) {
            let off = document.createElement('canvas');
            off.width = cols; off.height = rows;
            let octx = off.getContext('2d');
            octx.drawImage(img, 0, 0, cols, rows);
            let base64 = off.toDataURL('image/png');  // å®Œæ•´dataURL
            let pure = base64.split(',')[1];
            currentBase64 = withPrefix.checked ? base64 : pure;
            base64Result.value = currentBase64;
            copyBtn.disabled = false;
            saveTxtBtn.disabled = false;
            previewImage.src = base64;
        }

        imageFileInput.addEventListener('change', (e) => {
            if (e.target.files.length) {
                fileLabel.innerText = `ğŸ“ ${e.target.files[0].name}`;
            } else {
                fileLabel.innerText = 'ğŸ“ é€‰æ‹©å›¾ç‰‡ (è‡ªåŠ¨ç¼©å°è‡³ç”»å¸ƒå¤§å°)';
            }
        });

        importToCanvasBtn.addEventListener('click', () => {
            if (!imageFileInput.files.length) { alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡'); return; }
            loadImageFile(imageFileInput.files[0], (img) => {
                importImageToCanvas(img);
            });
        });

        importToBase64Btn.addEventListener('click', () => {
            if (!imageFileInput.files.length) { alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡'); return; }
            loadImageFile(imageFileInput.files[0], (img) => {
                importToBase64Only(img);
            });
        });

        // é™åˆ¶è¾“å…¥
        rowsInput.addEventListener('change', function(){ let v=parseInt(this.value); if(v>128) this.value=128; if(v<1) this.value=1; });
        colsInput.addEventListener('change', function(){ let v=parseInt(this.value); if(v>128) this.value=128; if(v<1) this.value=1; });

        // åˆå§‹åŒ–
        refreshCanvas();
        setActive('draw');
    })();
</script>
</body>
</html>