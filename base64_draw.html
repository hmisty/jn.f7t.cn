<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒç´ ç”»æ¿ Â· æ’¤é”€/é‡åš + ICO ä¿å­˜</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: system-ui, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        body {
            background: #eef0f5;
            margin: 0;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 12px;
        }
        .app-container {
            width: 1380px;
            max-width: 100%;
            background: #fff;
            border-radius: 24px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.12);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .paned-root {
            display: flex;
            flex: 1;
            min-height: 720px;
        }
        .left-panel {
            flex: 2.2;
            background: #f9fafc;
            border-right: 1px solid #dde3ed;
            display: flex;
            flex-direction: column;
            padding: 20px;
            min-width: 0;
        }
        .right-panel {
            flex: 1.2;
            background: #ffffff;
            display: flex;
            flex-direction: column;
            padding: 20px;
            min-width: 320px;
        }
        .control-panel {
            background: #ffffff;
            border-radius: 20px;
            padding: 16px 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.02);
            margin-bottom: 18px;
            border: 1px solid #e6ecf5;
        }
        .size-row {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 12px;
        }
        .size-row label {
            font-weight: 600;
            color: #334155;
            font-size: 0.9rem;
        }
        .size-input {
            width: 70px;
            padding: 8px 10px;
            border: 1px solid #cbd5e1;
            border-radius: 40px;
            text-align: center;
            font-size: 14px;
            background: #f8fafc;
        }
        .btn {
            background: #f1f4f9;
            border: none;
            padding: 8px 18px;
            border-radius: 40px;
            font-weight: 500;
            cursor: pointer;
            transition: 0.15s;
            box-shadow: 0 1px 4px rgba(0,0,0,0.05);
            font-size: 13px;
            border: 1px solid #d9e0eb;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .btn-primary {
            background: #3b6eff;
            color: white;
            border: none;
            box-shadow: 0 4px 10px rgba(59,110,255,0.2);
        }
        .btn-primary:hover {
            background: #2956d6;
        }
        .btn-tool {
            min-width: 70px;
            justify-content: center;
        }
        .btn-tool.active {
            background: #3b6eff;
            color: white;
            border-color: #1a45c9;
        }
        .btn-green {
            background: #e2f0e8;
            color: #1a6d3c;
            border-color: #b7dbc7;
        }
        .btn-green:hover {
            background: #c9e6d6;
        }
        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
            margin-top: 8px;
        }
        .undo-redo-group {
            margin-left: auto;
            display: flex;
            gap: 6px;
        }
        .color-box {
            width: 42px;
            height: 42px;
            border-radius: 12px;
            border: 3px solid #fff;
            box-shadow: 0 0 0 1px #aaa;
            cursor: pointer;
            transition: 0.1s;
        }
        .color-box:hover {
            transform: scale(1.07);
        }
        .color-label {
            font-family: 'Courier New', monospace;
            background: #edf2f7;
            padding: 8px 14px;
            border-radius: 40px;
            font-size: 13px;
            font-weight: 500;
        }
        .canvas-container {
            flex: 1;
            background: #dfe6f0;
            border-radius: 24px;
            padding: 18px;
            overflow: auto;
            border: 1px solid #cdd9e9;
            display: flex;
            justify-content: center;
            align-items: flex-start;
        }
        #pixelCanvas {
            display: block;
            background: white;
            box-shadow: 0 12px 30px rgba(0,0,0,0.15);
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            cursor: crosshair;
            border: 1px solid #98aec6;
        }
        .preview-area {
            background: #f6f9ff;
            border-radius: 20px;
            padding: 18px;
            text-align: center;
            margin-bottom: 20px;
            border: 1px solid #dee8f5;
        }
        .preview-title {
            font-weight: 700;
            margin-bottom: 12px;
            color: #1e293b;
            letter-spacing: 0.3px;
        }
        #previewImage {
            background: #e9eef4;
            border-radius: 16px;
            width: 100%;
            max-height: 150px;
            object-fit: contain;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
        }
        .options-group {
            background: #f7faff;
            border-radius: 18px;
            padding: 16px;
            border: 1px solid #dfe8f3;
            margin-bottom: 20px;
        }
        .option-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        .textarea-container {
            background: #f0f5fe;
            border-radius: 20px;
            padding: 16px;
            flex: 1;
            display: flex;
            flex-direction: column;
            border: 1px solid #cfdcf0;
        }
        #base64Result {
            width: 100%;
            min-height: 200px;
            border: none;
            background: white;
            border-radius: 16px;
            padding: 14px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            border: 1px solid #bccfe8;
        }
        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 12px;
            flex-wrap: wrap;
        }
        .status-bar {
            background: #eef3fa;
            padding: 10px 24px;
            font-size: 13px;
            border-top: 1px solid #cbd6e8;
            color: #274375;
            font-weight: 500;
        }
        hr {
            border: none;
            border-top: 1px solid #d9e2f0;
            margin: 10px 0;
        }
    </style>
</head>
<body>
<div class="app-container">
    <div class="paned-root">
        <!-- å·¦ä¾§ç»˜å›¾åŒº -->
        <div class="left-panel">
            <div class="control-panel">
                <!-- ç¬¬ä¸€è¡Œï¼šå°ºå¯¸ + æ–°å»º + æ’¤é”€é‡åš -->
                <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                    <div style="display: flex; align-items: center; gap: 6px;">
                        <label>è¡Œ:</label>
                        <input type="number" id="rowsInput" class="size-input" min="1" max="128" value="16">
                        <label>åˆ—:</label>
                        <input type="number" id="colsInput" class="size-input" min="1" max="128" value="16">
                    </div>
                    <button class="btn btn-primary" id="newCanvasBtn">âœ¨ æ–°å»ºç”»å¸ƒ</button>
                    <div class="undo-redo-group">
                        <button class="btn" id="undoBtn" title="æ’¤é”€ (Ctrl+Z)">â†©ï¸ æ’¤é”€</button>
                        <button class="btn" id="redoBtn" title="é‡åš (Ctrl+Y)">â†ªï¸ é‡åš</button>
                    </div>
                </div>

                <div class="tool-group">
                    <span style="font-weight:600;">å·¥å…·:</span>
                    <button class="btn btn-tool active" id="drawBtn" data-mode="draw">ğŸ–Œï¸ ç”»ç¬”</button>
                    <button class="btn btn-tool" id="eraseBtn" data-mode="erase">ğŸ§½ æ©¡çš®</button>
                    <button class="btn btn-tool" id="fillBtn" data-mode="fill">ğŸª£ å¡«å……</button>
                </div>

                <div class="tool-group" style="margin-top: 12px;">
                    <span style="font-weight:600;">é¢œè‰²:</span>
                    <div class="color-box" id="colorPickerBtn" style="background-color: #ff0000;"></div>
                    <span class="color-label" id="colorRgbLabel">RGB(255,0,0)</span>
                </div>

                <div class="tool-group" style="margin-top: 12px; justify-content: space-between;">
                    <span style="font-weight:600;">ä¿å­˜ä½œå“:</span>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button class="btn btn-green" id="savePngBtn">PNG</button>
                        <button class="btn btn-green" id="saveJpgBtn">JPG</button>
                        <button class="btn btn-green" id="saveBmpBtn">BMP</button>
                        <button class="btn btn-green" id="saveIcoBtn" style="background: #e6dfff; color:#4a2fc1;">ICO</button>
                    </div>
                </div>
            </div>

            <!-- ç”»å¸ƒåŒºåŸŸ -->
            <div class="canvas-container" id="canvasContainer">
                <canvas id="pixelCanvas"></canvas>
            </div>
        </div>

        <!-- å³ä¾§Base64åŒº -->
        <div class="right-panel">
            <h2 style="margin-top: 0; margin-bottom: 16px; font-size: 1.6rem; font-weight: 700;">Base64</h2>
            <div class="preview-area">
                <div class="preview-title">ğŸ“¸ å›¾ç‰‡é¢„è§ˆ</div>
                <img id="previewImage" src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22100%25%22%20height%3D%22100%25%22%20viewBox%3D%220%200%20100%20100%22%3E%3Crect%20width%3D%22100%25%22%20height%3D%22100%25%22%20fill%3D%22%23f0f0f0%22%2F%3E%3Ctext%20x%3D%2210%22%20y%3D%2255%22%20font-family%3D%22monospace%22%20font-size%3D%2212%22%20fill%3D%22%23999%22%3Eé¢„è§ˆ%3C%2Ftext%3E%3C%2Fsvg%3E" alt="preview">
            </div>

            <div class="options-group">
                <div class="option-item">
                    <input type="radio" name="base64Format" id="withPrefix" value="with_prefix" checked>
                    <label for="withPrefix">å¸¦å‰ç¼€ (data:image/png;base64,)</label>
                </div>
                <div class="option-item">
                    <input type="radio" name="base64Format" id="pureBase64" value="pure">
                    <label for="pureBase64">çº¯Base64</label>
                </div>
                <button class="btn btn-primary" id="convertBtn" style="width:100%; margin-top:12px;">ğŸ”„ è½¬æ¢ç”»ä½œä¸ºBase64</button>
            </div>

            <div class="textarea-container">
                <div style="font-weight:700; margin-bottom:8px;">ğŸ“‹ Base64 ç»“æœ</div>
                <textarea id="base64Result" readonly placeholder="ç‚¹å‡»è½¬æ¢ç”Ÿæˆâ€¦"></textarea>
                <div class="action-buttons">
                    <button class="btn" id="copyBtn" disabled>ğŸ“ å¤åˆ¶</button>
                    <button class="btn" id="saveTxtBtn" disabled>ğŸ“„ ä¿å­˜TXT</button>
                </div>
            </div>
        </div>
    </div>
    <!-- çŠ¶æ€æ  -->
    <div class="status-bar" id="statusBar">å°±ç»ª Â· æ”¯æŒæ’¤é”€/é‡åš (Ctrl+Z / Ctrl+Y)</div>
</div>

<script>
    (function(){
        // ----- é…ç½® -----
        let rows = 16;
        let cols = 16;
        const PIXEL_SIZE = 20;          // æ˜¾ç¤ºå¤§å°
        let currentColor = { r:255, g:0, b:0 };
        let mode = 'draw';
        let drawing = false;

        // åƒç´ æ•°æ® (äºŒç»´æ•°ç»„å­˜ {r,g,b})
        let pixels = [];

        // ----- æ’¤é”€/é‡åš ç³»ç»Ÿ (ä¿å­˜å®Œæ•´å¿«ç…§) -----
        const MAX_HISTORY = 50;
        let historyStack = [];           // å†å²çŠ¶æ€ (æ·±æ‹·è´)
        let historyIndex = -1;            // å½“å‰æ‰€åœ¨ä½ç½®çš„ç´¢å¼•

        // è·å–å½“å‰åƒç´ å¿«ç…§ (æ·±æ‹·è´)
        function getSnapshot() {
            return pixels.map(row => row.map(cell => ({r: cell.r, g: cell.g, b: cell.b})));
        }

        // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å² (é€šå¸¸åœ¨æ¯æ¬¡ç»˜åˆ¶åŠ¨ä½œå)
        function pushHistory() {
            // å¦‚æœå½“å‰ç´¢å¼•ä¸æ˜¯æœ€æ–°ï¼Œåˆ é™¤åé¢çš„åˆ†æ”¯
            if (historyIndex < historyStack.length - 1) {
                historyStack = historyStack.slice(0, historyIndex + 1);
            }
            const snap = getSnapshot();
            historyStack.push(snap);
            // é™åˆ¶é•¿åº¦
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }
            historyIndex = historyStack.length - 1;
            // æ›´æ–°æŒ‰é’®çŠ¶æ€ (æ²¡æœ‰ç¦ç”¨ä½†å¯ä»¥è§†è§‰æç¤º)
        }

        // æ’¤é”€: å›åˆ°ä¸Šä¸€ä¸ªçŠ¶æ€
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                pixels = historyStack[historyIndex].map(row => row.map(cell => ({r: cell.r, g: cell.g, b: cell.b})));
                refreshCanvas();
                statusBar.innerText = `æ’¤é”€ Â· å†å²ä½ç½® ${historyIndex+1}/${historyStack.length}`;
            } else {
                statusBar.innerText = 'å·²ç»åœ¨æœ€æ—©çš„å†å²è®°å½•';
            }
        }

        // é‡åš: å‰è¿›åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€
        function redo() {
            if (historyIndex < historyStack.length - 1) {
                historyIndex++;
                pixels = historyStack[historyIndex].map(row => row.map(cell => ({r: cell.r, g: cell.g, b: cell.b})));
                refreshCanvas();
                statusBar.innerText = `é‡åš Â· å†å²ä½ç½® ${historyIndex+1}/${historyStack.length}`;
            } else {
                statusBar.innerText = 'å·²ç»æ˜¯æœ€æ–°çŠ¶æ€';
            }
        }

        // åˆå§‹åŒ–å†å² (ç¬¬ä¸€æ¬¡)
        function resetHistory(initialPixels) {
            historyStack = [initialPixels.map(row => row.map(c => ({r: c.r, g: c.g, b: c.b})))];
            historyIndex = 0;
        }

        // å·¥å…·: åˆå§‹åŒ–å…¨ç™½ç”»å¸ƒ
        function createWhitePixels(r, c) {
            const arr = [];
            for (let i=0; i<r; i++) {
                const row = [];
                for (let j=0; j<c; j++) row.push({r:255,g:255,b:255});
                arr.push(row);
            }
            return arr;
        }

        // åˆå§‹åŒ–
        pixels = createWhitePixels(rows, cols);
        resetHistory(pixels);

        // DOM å…ƒç´ 
        const canvas = document.getElementById('pixelCanvas');
        const ctx = canvas.getContext('2d');
        const rowsInput = document.getElementById('rowsInput');
        const colsInput = document.getElementById('colsInput');
        const newCanvasBtn = document.getElementById('newCanvasBtn');
        const drawBtn = document.getElementById('drawBtn');
        const eraseBtn = document.getElementById('eraseBtn');
        const fillBtn = document.getElementById('fillBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const colorPickerBtn = document.getElementById('colorPickerBtn');
        const colorRgbLabel = document.getElementById('colorRgbLabel');
        const savePngBtn = document.getElementById('savePngBtn');
        const saveJpgBtn = document.getElementById('saveJpgBtn');
        const saveBmpBtn = document.getElementById('saveBmpBtn');
        const saveIcoBtn = document.getElementById('saveIcoBtn');
        const convertBtn = document.getElementById('convertBtn');
        const base64ResultArea = document.getElementById('base64Result');
        const copyBtn = document.getElementById('copyBtn');
        const saveTxtBtn = document.getElementById('saveTxtBtn');
        const previewImage = document.getElementById('previewImage');
        const statusBar = document.getElementById('statusBar');
        const withPrefixRadio = document.getElementById('withPrefix');
        const pureBase64Radio = document.getElementById('pureBase64');

        let currentBase64 = '';

        // ----- ç»˜å›¾å‡½æ•° -----
        function drawGrid() {
            canvas.width = cols * PIXEL_SIZE;
            canvas.height = rows * PIXEL_SIZE;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i=0; i<rows; i++) {
                for (let j=0; j<cols; j++) {
                    const p = pixels[i][j];
                    ctx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                    ctx.fillRect(j*PIXEL_SIZE, i*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                    ctx.strokeStyle = '#ccc';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(j*PIXEL_SIZE, i*PIXEL_SIZE, PIXEL_SIZE, PIXEL_SIZE);
                }
            }
        }

        function refreshCanvas() { drawGrid(); }

        // è®¾ç½®å·¥å…·æ¿€æ´»æ ·å¼
        function setActiveTool(tool) {
            [drawBtn, eraseBtn, fillBtn].forEach(b => b.classList.remove('active'));
            if (tool === 'draw') drawBtn.classList.add('active');
            else if (tool === 'erase') eraseBtn.classList.add('active');
            else if (tool === 'fill') fillBtn.classList.add('active');
            mode = tool;
            statusBar.innerText = `å½“å‰æ¨¡å¼: ${tool==='draw'?'ç”»ç¬”':tool==='erase'?'æ©¡çš®':'å¡«å……'}`;
        }

        // é¼ æ ‡åæ ‡è½¬æ ¼å­ç´¢å¼•
        function getPixelIndex(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const canvasX = (e.clientX - rect.left) * scaleX;
            const canvasY = (e.clientY - rect.top) * scaleY;
            if (canvasX<0 || canvasY<0 || canvasX>=canvas.width || canvasY>=canvas.height) return null;
            const col = Math.floor(canvasX / PIXEL_SIZE);
            const row = Math.floor(canvasY / PIXEL_SIZE);
            if (row<0 || row>=rows || col<0 || col>=cols) return null;
            return {row, col};
        }

        // å¡«å……ç®—æ³• BFS
        function floodFill(row, col, targetColor, newColor) {
            if (targetColor.r === newColor.r && targetColor.g === newColor.g && targetColor.b === newColor.b) return;
            const queue = [{row, col}];
            const visited = new Set();
            while (queue.length) {
                const {row: r, col: c} = queue.shift();
                const key = `${r},${c}`;
                if (r<0 || r>=rows || c<0 || c>=cols || visited.has(key)) continue;
                const cur = pixels[r][c];
                if (cur.r !== targetColor.r || cur.g !== targetColor.g || cur.b !== targetColor.b) continue;
                pixels[r][c] = {r: newColor.r, g: newColor.g, b: newColor.b};
                visited.add(key);
                queue.push({row: r+1, col: c});
                queue.push({row: r-1, col: c});
                queue.push({row: r, col: c+1});
                queue.push({row: r, col: c-1});
            }
        }

        // æ‰§è¡Œç»˜åˆ¶ (å•ç‚¹/å¡«å……)
        function applyDraw(row, col, skipHistory = false) {
            if (mode === 'draw') {
                pixels[row][col] = {r: currentColor.r, g: currentColor.g, b: currentColor.b};
            } else if (mode === 'erase') {
                pixels[row][col] = {r:255,g:255,b:255};
            } else if (mode === 'fill') {
                const target = pixels[row][col];
                floodFill(row, col, target, currentColor);
            }
            refreshCanvas();
        }

        // å°è£…ç»˜åˆ¶åŠ¨ä½œå¹¶è‡ªåŠ¨ä¿å­˜å†å² (ç”¨äºé¼ æ ‡äº‹ä»¶)
        function handleDrawWithHistory(row, col) {
            if (mode === 'fill') {
                // å¡«å……å¯èƒ½æ”¹åŠ¨å¤§é‡æ ¼å­ï¼Œå¿«ç…§å‰ç½®ä¿å­˜
                pushHistory();               // å¡«å……å‰çš„çŠ¶æ€
                applyDraw(row, col, true);
            } else {
                // ç”»ç¬”/æ©¡çš®ï¼šå•æ ¼ï¼Œä½†ä¹Ÿè¦ä¿å­˜å†å² (ä½†æˆ‘ä»¬å¸Œæœ›è¿ç»­æ‹–åŠ¨åªå­˜ä¸€æ¬¡ï¼Ÿä¸ºäº†ç®€å•ï¼Œæ¯æ¬¡é¼ æ ‡æ¾å¼€å†ç»Ÿä¸€ä¿å­˜ã€‚ä½†mousemoveä¼šå¤šæ¬¡è§¦å‘)
                // æ–¹æ¡ˆï¼šåœ¨mouseupæ—¶ä¿å­˜ä¸€æ¬¡å†å²ï¼›ç»˜åˆ¶è¿‡ç¨‹ä¸­ç›´æ¥ä¿®æ”¹å¹¶é‡ç»˜ï¼Œä½†å†å²ä¸è®°å½•ï¼Œç›´åˆ°æ¾å¼€ã€‚
                // æˆ‘ä»¬é‡‡ç”¨ï¼šé¼ æ ‡æŒ‰ä¸‹/æ‹–åŠ¨å®æ—¶ä¿®æ”¹ï¼Œä¸è®°å½•å†å²ï¼›é¼ æ ‡æ¾å¼€æ—¶pushä¸€æ¬¡å†å²ï¼ˆå¦‚æœæ ¼å­æœ‰å˜åŒ–ï¼‰ã€‚
                // éœ€è¦è®°å½•æ˜¯å¦ä¿®æ”¹è¿‡ã€‚ç”¨dirtyæ ‡è®°ã€‚
                applyDraw(row, col, true);
            }
        }

        // é¼ æ ‡äº‹ä»¶ + å†å²ä¼˜åŒ– (æ¾å¼€æ—¶è®°å½•)
        let dirtySinceLastPush = false;

        function onMouseDown(e) {
            e.preventDefault();
            drawing = true;
            dirtySinceLastPush = false;  // æ–°æ‹–æ‹½é‡ç½®
            const idx = getPixelIndex(e);
            if (!idx) return;
            if (mode === 'fill') {
                pushHistory();            // å¡«å……å‰è®°å½•
                applyDraw(idx.row, idx.col, true);
                dirtySinceLastPush = false; // å¡«å……å·²å•ç‹¬è®°å½•å†å²ï¼Œä¸éœ€è¦mouseupå†å­˜
            } else {
                // ç”»ç¬”/æ©¡çš®: å…ˆç”»ä¸€ç‚¹
                const before = pixels[idx.row][idx.col];
                applyDraw(idx.row, idx.col, true);
                const after = pixels[idx.row][idx.col];
                if (before.r !== after.r || before.g !== after.g || before.b !== after.b) {
                    dirtySinceLastPush = true;
                }
            }
        }

        function onMouseMove(e) {
            if (!drawing || mode === 'fill') return;
            const idx = getPixelIndex(e);
            if (!idx) return;
            const before = pixels[idx.row][idx.col];
            applyDraw(idx.row, idx.col, true);
            const after = pixels[idx.row][idx.col];
            if (before.r !== after.r || before.g !== after.g || before.b !== after.b) {
                dirtySinceLastPush = true;
            }
        }

        function onMouseUp(e) {
            if (drawing && dirtySinceLastPush && mode !== 'fill') {
                pushHistory();   // ä¿å­˜æ•´ä¸ªæ‹–æ‹½ç¬”ç”»
            }
            drawing = false;
            dirtySinceLastPush = false;
        }

        // æ³¨å†Œäº‹ä»¶
        canvas.addEventListener('mousedown', onMouseDown);
        canvas.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);

        // å·¥å…·åˆ‡æ¢
        drawBtn.addEventListener('click', () => setActiveTool('draw'));
        eraseBtn.addEventListener('click', () => setActiveTool('erase'));
        fillBtn.addEventListener('click', () => setActiveTool('fill'));

        // é¢œè‰²é€‰æ‹©
        function openColorPicker() {
            const input = document.createElement('input');
            input.type = 'color';
            input.value = `#${((1 << 24) + (currentColor.r << 16) + (currentColor.g << 8) + currentColor.b).toString(16).slice(1)}`;
            input.addEventListener('input', (e) => {
                const hex = e.target.value;
                const r = parseInt(hex.slice(1,3), 16);
                const g = parseInt(hex.slice(3,5), 16);
                const b = parseInt(hex.slice(5,7), 16);
                currentColor = {r, g, b};
                colorPickerBtn.style.backgroundColor = `rgb(${r},${g},${b})`;
                colorRgbLabel.innerText = `RGB(${r},${g},${b})`;
            });
            input.click();
        }
        colorPickerBtn.addEventListener('click', openColorPicker);

        // æ–°å»ºç”»å¸ƒ
        newCanvasBtn.addEventListener('click', () => {
            let r = parseInt(rowsInput.value) || 16;
            let c = parseInt(colsInput.value) || 16;
            r = Math.min(128, Math.max(1, r));
            c = Math.min(128, Math.max(1, c));
            rows = r; cols = c;
            rowsInput.value = rows;
            colsInput.value = cols;
            pixels = createWhitePixels(rows, cols);
            resetHistory(pixels);
            refreshCanvas();
            statusBar.innerText = `æ–°å»ºç”»å¸ƒ ${rows}x${cols} Â· å†å²å·²é‡ç½®`;
        });

        // æ’¤é”€/é‡åšæŒ‰é’®
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        // é”®ç›˜å¿«æ·é”® Ctrl+Z / Ctrl+Y
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' || e.key === 'Z') {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'y' || e.key === 'Y') {
                    e.preventDefault();
                    redo();
                }
            }
        });

        // ä¿å­˜å›¾ç‰‡é€šç”¨ (format: png, jpg, bmp, ico)
        function saveImage(format) {
            const offCanvas = document.createElement('canvas');
            offCanvas.width = cols;
            offCanvas.height = rows;
            const offCtx = offCanvas.getContext('2d');
            for (let i=0; i<rows; i++) {
                for (let j=0; j<cols; j++) {
                    const p = pixels[i][j];
                    offCtx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                    offCtx.fillRect(j, i, 1, 1);
                }
            }
            let mime = 'image/png';
            let ext = 'png';
            if (format === 'jpg') { mime = 'image/jpeg'; ext='jpg'; }
            else if (format === 'bmp') { mime = 'image/bmp'; ext='bmp'; }
            else if (format === 'ico') { mime = 'image/x-icon'; ext='ico'; }  // å¤§å¤šæ•°æµè§ˆå™¨ä¼šå°†icoæŒ‰pngå¤„ç†ï¼Ÿä½†ä¿å­˜ä¸º.icoæ–‡ä»¶ã€‚

            offCanvas.toBlob((blob) => {
                if (!blob) return;
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pixel_art.${ext}`;
                a.click();
                URL.revokeObjectURL(url);
                statusBar.innerText = `ä¿å­˜ä¸º .${ext} æ–‡ä»¶`;
            }, mime);
        }

        savePngBtn.addEventListener('click', () => saveImage('png'));
        saveJpgBtn.addEventListener('click', () => saveImage('jpg'));
        saveBmpBtn.addEventListener('click', () => saveImage('bmp'));
        saveIcoBtn.addEventListener('click', () => saveImage('ico'));

        // è½¬æ¢Base64
        convertBtn.addEventListener('click', () => {
            const offCanvas = document.createElement('canvas');
            offCanvas.width = cols;
            offCanvas.height = rows;
            const offCtx = offCanvas.getContext('2d');
            for (let i=0; i<rows; i++) {
                for (let j=0; j<cols; j++) {
                    const p = pixels[i][j];
                    offCtx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                    offCtx.fillRect(j, i, 1, 1);
                }
            }
            offCanvas.toBlob((blob) => {
                const reader = new FileReader();
                reader.onloadend = function() {
                    const base64 = reader.result.split(',')[1];
                    const withPrefix = `data:image/png;base64,${base64}`;
                    const format = withPrefixRadio.checked ? 'with_prefix' : 'pure';
                    currentBase64 = format === 'with_prefix' ? withPrefix : base64;
                    base64ResultArea.value = currentBase64;
                    copyBtn.disabled = false;
                    saveTxtBtn.disabled = false;

                    // é¢„è§ˆç¼©ç•¥å›¾
                    const previewCanvas = document.createElement('canvas');
                    previewCanvas.width = cols;
                    previewCanvas.height = rows;
                    const pCtx = previewCanvas.getContext('2d');
                    for (let i=0; i<rows; i++) {
                        for (let j=0; j<cols; j++) {
                            const p = pixels[i][j];
                            pCtx.fillStyle = `rgb(${p.r},${p.g},${p.b})`;
                            pCtx.fillRect(j, i, 1, 1);
                        }
                    }
                    previewImage.src = previewCanvas.toDataURL('image/png');
                    statusBar.innerText = `Base64 é•¿åº¦: ${currentBase64.length}`;
                };
                reader.readAsDataURL(blob);
            }, 'image/png');
        });

        copyBtn.addEventListener('click', () => {
            if (!currentBase64) return;
            navigator.clipboard.writeText(currentBase64).then(() => {
                statusBar.innerText = 'å¤åˆ¶æˆåŠŸ';
            }).catch(() => alert('å¤åˆ¶å¤±è´¥'));
        });

        saveTxtBtn.addEventListener('click', () => {
            if (!currentBase64) return;
            const blob = new Blob([currentBase64], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'pixel_base64.txt';
            a.click();
            URL.revokeObjectURL(url);
            statusBar.innerText = 'TXT å·²ä¿å­˜';
        });

        // åˆå§‹åŒ–
        refreshCanvas();
        setActiveTool('draw');
        resetHistory(pixels);

        // èŒƒå›´æ ¡éªŒ
        rowsInput.addEventListener('change', function(){ let v=parseInt(this.value); if(v>128) this.value=128; if(v<1) this.value=1; });
        colsInput.addEventListener('change', function(){ let v=parseInt(this.value); if(v>128) this.value=128; if(v<1) this.value=1; });
    })();
</script>
</body>
</html>